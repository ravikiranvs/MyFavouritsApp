/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.1.0 (NJsonSchema v10.5.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class WebApiClientBase {
    protected getBaseUrl(domain: string, baseUrl: string | undefined) {
        return window.location.origin;
    }
}

export class RedditDataClient extends WebApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @param token (optional) 
     * @return Success
     */
    favourits(token: string | null | undefined): Promise<RedditFavouritsResponceRoot> {
        let url_ = this.baseUrl + "/api/RedditData/favourits?";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFavourits(_response);
        });
    }

    protected processFavourits(response: Response): Promise<RedditFavouritsResponceRoot> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RedditFavouritsResponceRoot.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RedditFavouritsResponceRoot>(<any>null);
    }

    /**
     * @param token (optional) 
     * @return Success
     */
    userInfo(token: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/RedditData/user-info?";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserInfo(_response);
        });
    }

    protected processUserInfo(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export class TokenClient extends WebApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @param userToken (optional) 
     * @param body (optional) 
     * @return Success
     */
    reddit(userToken: string | null | undefined, body: string | null | undefined): Promise<UserTokenData> {
        let url_ = this.baseUrl + "/api/Token/reddit?";
        if (userToken !== undefined && userToken !== null)
            url_ += "userToken=" + encodeURIComponent("" + userToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReddit(_response);
        });
    }

    protected processReddit(response: Response): Promise<UserTokenData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserTokenData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserTokenData>(<any>null);
    }
}

export class Client extends WebApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return Success
     */
    weatherForecast(): Promise<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWeatherForecast(_response);
        });
    }

    protected processWeatherForecast(response: Response): Promise<WeatherForecast[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WeatherForecast[]>(<any>null);
    }
}

export class Link_Flair_Richtext implements ILink_Flair_Richtext {
    e?: string | undefined;
    t?: string | undefined;

    constructor(data?: ILink_Flair_Richtext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.e = _data["e"];
            this.t = _data["t"];
        }
    }

    static fromJS(data: any): Link_Flair_Richtext {
        data = typeof data === 'object' ? data : {};
        let result = new Link_Flair_Richtext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["e"] = this.e;
        data["t"] = this.t;
        return data; 
    }
}

export interface ILink_Flair_Richtext {
    e?: string | undefined;
    t?: string | undefined;
}

export class Media_Embed implements IMedia_Embed {
    content?: string | undefined;
    width?: number;
    scrolling?: boolean;
    height?: number;

    constructor(data?: IMedia_Embed) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.width = _data["width"];
            this.scrolling = _data["scrolling"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): Media_Embed {
        data = typeof data === 'object' ? data : {};
        let result = new Media_Embed();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["width"] = this.width;
        data["scrolling"] = this.scrolling;
        data["height"] = this.height;
        return data; 
    }
}

export interface IMedia_Embed {
    content?: string | undefined;
    width?: number;
    scrolling?: boolean;
    height?: number;
}

export class Oembed implements IOembed {
    provider_url?: string | undefined;
    version?: string | undefined;
    title?: string | undefined;
    type?: string | undefined;
    thumbnail_width?: number;
    height?: number;
    width?: number;
    html?: string | undefined;
    author_name?: string | undefined;
    provider_name?: string | undefined;
    thumbnail_url?: string | undefined;
    thumbnail_height?: number;
    author_url?: string | undefined;

    constructor(data?: IOembed) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provider_url = _data["provider_url"];
            this.version = _data["version"];
            this.title = _data["title"];
            this.type = _data["type"];
            this.thumbnail_width = _data["thumbnail_width"];
            this.height = _data["height"];
            this.width = _data["width"];
            this.html = _data["html"];
            this.author_name = _data["author_name"];
            this.provider_name = _data["provider_name"];
            this.thumbnail_url = _data["thumbnail_url"];
            this.thumbnail_height = _data["thumbnail_height"];
            this.author_url = _data["author_url"];
        }
    }

    static fromJS(data: any): Oembed {
        data = typeof data === 'object' ? data : {};
        let result = new Oembed();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider_url"] = this.provider_url;
        data["version"] = this.version;
        data["title"] = this.title;
        data["type"] = this.type;
        data["thumbnail_width"] = this.thumbnail_width;
        data["height"] = this.height;
        data["width"] = this.width;
        data["html"] = this.html;
        data["author_name"] = this.author_name;
        data["provider_name"] = this.provider_name;
        data["thumbnail_url"] = this.thumbnail_url;
        data["thumbnail_height"] = this.thumbnail_height;
        data["author_url"] = this.author_url;
        return data; 
    }
}

export interface IOembed {
    provider_url?: string | undefined;
    version?: string | undefined;
    title?: string | undefined;
    type?: string | undefined;
    thumbnail_width?: number;
    height?: number;
    width?: number;
    html?: string | undefined;
    author_name?: string | undefined;
    provider_name?: string | undefined;
    thumbnail_url?: string | undefined;
    thumbnail_height?: number;
    author_url?: string | undefined;
}

export class Secure_Media implements ISecure_Media {
    type?: string | undefined;
    oembed?: Oembed;

    constructor(data?: ISecure_Media) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.oembed = _data["oembed"] ? Oembed.fromJS(_data["oembed"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Secure_Media {
        data = typeof data === 'object' ? data : {};
        let result = new Secure_Media();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["oembed"] = this.oembed ? this.oembed.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISecure_Media {
    type?: string | undefined;
    oembed?: Oembed;
}

export class Secure_Media_Embed implements ISecure_Media_Embed {
    content?: string | undefined;
    width?: number;
    scrolling?: boolean;
    media_domain_url?: string | undefined;
    height?: number;

    constructor(data?: ISecure_Media_Embed) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.width = _data["width"];
            this.scrolling = _data["scrolling"];
            this.media_domain_url = _data["media_domain_url"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): Secure_Media_Embed {
        data = typeof data === 'object' ? data : {};
        let result = new Secure_Media_Embed();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["width"] = this.width;
        data["scrolling"] = this.scrolling;
        data["media_domain_url"] = this.media_domain_url;
        data["height"] = this.height;
        return data; 
    }
}

export interface ISecure_Media_Embed {
    content?: string | undefined;
    width?: number;
    scrolling?: boolean;
    media_domain_url?: string | undefined;
    height?: number;
}

export class Author_Flair_Richtext implements IAuthor_Flair_Richtext {
    a?: string | undefined;
    e?: string | undefined;
    u?: string | undefined;
    t?: string | undefined;

    constructor(data?: IAuthor_Flair_Richtext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.a = _data["a"];
            this.e = _data["e"];
            this.u = _data["u"];
            this.t = _data["t"];
        }
    }

    static fromJS(data: any): Author_Flair_Richtext {
        data = typeof data === 'object' ? data : {};
        let result = new Author_Flair_Richtext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["a"] = this.a;
        data["e"] = this.e;
        data["u"] = this.u;
        data["t"] = this.t;
        return data; 
    }
}

export interface IAuthor_Flair_Richtext {
    a?: string | undefined;
    e?: string | undefined;
    u?: string | undefined;
    t?: string | undefined;
}

export class Gildings implements IGildings {
    gid_1?: number;
    gid_2?: number;
    gid_3?: number;

    constructor(data?: IGildings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gid_1 = _data["gid_1"];
            this.gid_2 = _data["gid_2"];
            this.gid_3 = _data["gid_3"];
        }
    }

    static fromJS(data: any): Gildings {
        data = typeof data === 'object' ? data : {};
        let result = new Gildings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gid_1"] = this.gid_1;
        data["gid_2"] = this.gid_2;
        data["gid_3"] = this.gid_3;
        return data; 
    }
}

export interface IGildings {
    gid_1?: number;
    gid_2?: number;
    gid_3?: number;
}

export class Resized_Icons implements IResized_Icons {
    url?: string | undefined;
    width?: number;
    height?: number;

    constructor(data?: IResized_Icons) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): Resized_Icons {
        data = typeof data === 'object' ? data : {};
        let result = new Resized_Icons();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface IResized_Icons {
    url?: string | undefined;
    width?: number;
    height?: number;
}

export class Resized_Static_Icons implements IResized_Static_Icons {
    url?: string | undefined;
    width?: number;
    height?: number;

    constructor(data?: IResized_Static_Icons) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): Resized_Static_Icons {
        data = typeof data === 'object' ? data : {};
        let result = new Resized_Static_Icons();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface IResized_Static_Icons {
    url?: string | undefined;
    width?: number;
    height?: number;
}

export class All_Awardings implements IAll_Awardings {
    giver_coin_reward?: number | undefined;
    subreddit_id?: any | undefined;
    is_new?: boolean;
    days_of_drip_extension?: number;
    coin_price?: number;
    id?: string | undefined;
    penny_donate?: number | undefined;
    award_sub_type?: string | undefined;
    coin_reward?: number;
    icon_url?: string | undefined;
    days_of_premium?: number;
    tiers_by_required_awardings?: any | undefined;
    resized_icons?: Resized_Icons[] | undefined;
    icon_width?: number;
    static_icon_width?: number;
    start_date?: any | undefined;
    is_enabled?: boolean;
    awardings_required_to_grant_benefits?: any | undefined;
    description?: string | undefined;
    end_date?: any | undefined;
    subreddit_coin_reward?: number;
    count?: number;
    static_icon_height?: number;
    name?: string | undefined;
    resized_static_icons?: Resized_Static_Icons[] | undefined;
    icon_format?: string | undefined;
    icon_height?: number;
    penny_price?: number | undefined;
    award_type?: string | undefined;
    static_icon_url?: string | undefined;

    constructor(data?: IAll_Awardings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.giver_coin_reward = _data["giver_coin_reward"];
            this.subreddit_id = _data["subreddit_id"];
            this.is_new = _data["is_new"];
            this.days_of_drip_extension = _data["days_of_drip_extension"];
            this.coin_price = _data["coin_price"];
            this.id = _data["id"];
            this.penny_donate = _data["penny_donate"];
            this.award_sub_type = _data["award_sub_type"];
            this.coin_reward = _data["coin_reward"];
            this.icon_url = _data["icon_url"];
            this.days_of_premium = _data["days_of_premium"];
            this.tiers_by_required_awardings = _data["tiers_by_required_awardings"];
            if (Array.isArray(_data["resized_icons"])) {
                this.resized_icons = [] as any;
                for (let item of _data["resized_icons"])
                    this.resized_icons!.push(Resized_Icons.fromJS(item));
            }
            this.icon_width = _data["icon_width"];
            this.static_icon_width = _data["static_icon_width"];
            this.start_date = _data["start_date"];
            this.is_enabled = _data["is_enabled"];
            this.awardings_required_to_grant_benefits = _data["awardings_required_to_grant_benefits"];
            this.description = _data["description"];
            this.end_date = _data["end_date"];
            this.subreddit_coin_reward = _data["subreddit_coin_reward"];
            this.count = _data["count"];
            this.static_icon_height = _data["static_icon_height"];
            this.name = _data["name"];
            if (Array.isArray(_data["resized_static_icons"])) {
                this.resized_static_icons = [] as any;
                for (let item of _data["resized_static_icons"])
                    this.resized_static_icons!.push(Resized_Static_Icons.fromJS(item));
            }
            this.icon_format = _data["icon_format"];
            this.icon_height = _data["icon_height"];
            this.penny_price = _data["penny_price"];
            this.award_type = _data["award_type"];
            this.static_icon_url = _data["static_icon_url"];
        }
    }

    static fromJS(data: any): All_Awardings {
        data = typeof data === 'object' ? data : {};
        let result = new All_Awardings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["giver_coin_reward"] = this.giver_coin_reward;
        data["subreddit_id"] = this.subreddit_id;
        data["is_new"] = this.is_new;
        data["days_of_drip_extension"] = this.days_of_drip_extension;
        data["coin_price"] = this.coin_price;
        data["id"] = this.id;
        data["penny_donate"] = this.penny_donate;
        data["award_sub_type"] = this.award_sub_type;
        data["coin_reward"] = this.coin_reward;
        data["icon_url"] = this.icon_url;
        data["days_of_premium"] = this.days_of_premium;
        data["tiers_by_required_awardings"] = this.tiers_by_required_awardings;
        if (Array.isArray(this.resized_icons)) {
            data["resized_icons"] = [];
            for (let item of this.resized_icons)
                data["resized_icons"].push(item.toJSON());
        }
        data["icon_width"] = this.icon_width;
        data["static_icon_width"] = this.static_icon_width;
        data["start_date"] = this.start_date;
        data["is_enabled"] = this.is_enabled;
        data["awardings_required_to_grant_benefits"] = this.awardings_required_to_grant_benefits;
        data["description"] = this.description;
        data["end_date"] = this.end_date;
        data["subreddit_coin_reward"] = this.subreddit_coin_reward;
        data["count"] = this.count;
        data["static_icon_height"] = this.static_icon_height;
        data["name"] = this.name;
        if (Array.isArray(this.resized_static_icons)) {
            data["resized_static_icons"] = [];
            for (let item of this.resized_static_icons)
                data["resized_static_icons"].push(item.toJSON());
        }
        data["icon_format"] = this.icon_format;
        data["icon_height"] = this.icon_height;
        data["penny_price"] = this.penny_price;
        data["award_type"] = this.award_type;
        data["static_icon_url"] = this.static_icon_url;
        return data; 
    }
}

export interface IAll_Awardings {
    giver_coin_reward?: number | undefined;
    subreddit_id?: any | undefined;
    is_new?: boolean;
    days_of_drip_extension?: number;
    coin_price?: number;
    id?: string | undefined;
    penny_donate?: number | undefined;
    award_sub_type?: string | undefined;
    coin_reward?: number;
    icon_url?: string | undefined;
    days_of_premium?: number;
    tiers_by_required_awardings?: any | undefined;
    resized_icons?: Resized_Icons[] | undefined;
    icon_width?: number;
    static_icon_width?: number;
    start_date?: any | undefined;
    is_enabled?: boolean;
    awardings_required_to_grant_benefits?: any | undefined;
    description?: string | undefined;
    end_date?: any | undefined;
    subreddit_coin_reward?: number;
    count?: number;
    static_icon_height?: number;
    name?: string | undefined;
    resized_static_icons?: Resized_Static_Icons[] | undefined;
    icon_format?: string | undefined;
    icon_height?: number;
    penny_price?: number | undefined;
    award_type?: string | undefined;
    static_icon_url?: string | undefined;
}

export class Oembed1 implements IOembed1 {
    provider_url?: string | undefined;
    version?: string | undefined;
    title?: string | undefined;
    type?: string | undefined;
    thumbnail_width?: number;
    height?: number;
    width?: number;
    html?: string | undefined;
    author_name?: string | undefined;
    provider_name?: string | undefined;
    thumbnail_url?: string | undefined;
    thumbnail_height?: number;
    author_url?: string | undefined;

    constructor(data?: IOembed1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provider_url = _data["provider_url"];
            this.version = _data["version"];
            this.title = _data["title"];
            this.type = _data["type"];
            this.thumbnail_width = _data["thumbnail_width"];
            this.height = _data["height"];
            this.width = _data["width"];
            this.html = _data["html"];
            this.author_name = _data["author_name"];
            this.provider_name = _data["provider_name"];
            this.thumbnail_url = _data["thumbnail_url"];
            this.thumbnail_height = _data["thumbnail_height"];
            this.author_url = _data["author_url"];
        }
    }

    static fromJS(data: any): Oembed1 {
        data = typeof data === 'object' ? data : {};
        let result = new Oembed1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider_url"] = this.provider_url;
        data["version"] = this.version;
        data["title"] = this.title;
        data["type"] = this.type;
        data["thumbnail_width"] = this.thumbnail_width;
        data["height"] = this.height;
        data["width"] = this.width;
        data["html"] = this.html;
        data["author_name"] = this.author_name;
        data["provider_name"] = this.provider_name;
        data["thumbnail_url"] = this.thumbnail_url;
        data["thumbnail_height"] = this.thumbnail_height;
        data["author_url"] = this.author_url;
        return data; 
    }
}

export interface IOembed1 {
    provider_url?: string | undefined;
    version?: string | undefined;
    title?: string | undefined;
    type?: string | undefined;
    thumbnail_width?: number;
    height?: number;
    width?: number;
    html?: string | undefined;
    author_name?: string | undefined;
    provider_name?: string | undefined;
    thumbnail_url?: string | undefined;
    thumbnail_height?: number;
    author_url?: string | undefined;
}

export class Media implements IMedia {
    type?: string | undefined;
    oembed?: Oembed1;

    constructor(data?: IMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.oembed = _data["oembed"] ? Oembed1.fromJS(_data["oembed"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Media {
        data = typeof data === 'object' ? data : {};
        let result = new Media();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["oembed"] = this.oembed ? this.oembed.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMedia {
    type?: string | undefined;
    oembed?: Oembed1;
}

export class Source implements ISource {
    url?: string | undefined;
    width?: number;
    height?: number;

    constructor(data?: ISource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): Source {
        data = typeof data === 'object' ? data : {};
        let result = new Source();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface ISource {
    url?: string | undefined;
    width?: number;
    height?: number;
}

export class Resolution2 implements IResolution2 {
    url?: string | undefined;
    width?: number;
    height?: number;

    constructor(data?: IResolution2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): Resolution2 {
        data = typeof data === 'object' ? data : {};
        let result = new Resolution2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface IResolution2 {
    url?: string | undefined;
    width?: number;
    height?: number;
}

export class Source1 implements ISource1 {
    url?: string | undefined;
    width?: number;
    height?: number;

    constructor(data?: ISource1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): Source1 {
        data = typeof data === 'object' ? data : {};
        let result = new Source1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface ISource1 {
    url?: string | undefined;
    width?: number;
    height?: number;
}

export class Resolution implements IResolution {
    url?: string | undefined;
    width?: number;
    height?: number;

    constructor(data?: IResolution) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): Resolution {
        data = typeof data === 'object' ? data : {};
        let result = new Resolution();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface IResolution {
    url?: string | undefined;
    width?: number;
    height?: number;
}

export class Gif implements IGif {
    source?: Source1;
    resolutions?: Resolution[] | undefined;

    constructor(data?: IGif) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.source = _data["source"] ? Source1.fromJS(_data["source"]) : <any>undefined;
            if (Array.isArray(_data["resolutions"])) {
                this.resolutions = [] as any;
                for (let item of _data["resolutions"])
                    this.resolutions!.push(Resolution.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Gif {
        data = typeof data === 'object' ? data : {};
        let result = new Gif();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        if (Array.isArray(this.resolutions)) {
            data["resolutions"] = [];
            for (let item of this.resolutions)
                data["resolutions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGif {
    source?: Source1;
    resolutions?: Resolution[] | undefined;
}

export class Source2 implements ISource2 {
    url?: string | undefined;
    width?: number;
    height?: number;

    constructor(data?: ISource2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): Source2 {
        data = typeof data === 'object' ? data : {};
        let result = new Source2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface ISource2 {
    url?: string | undefined;
    width?: number;
    height?: number;
}

export class Resolution1 implements IResolution1 {
    url?: string | undefined;
    width?: number;
    height?: number;

    constructor(data?: IResolution1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): Resolution1 {
        data = typeof data === 'object' ? data : {};
        let result = new Resolution1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface IResolution1 {
    url?: string | undefined;
    width?: number;
    height?: number;
}

export class Mp4 implements IMp4 {
    source?: Source2;
    resolutions?: Resolution1[] | undefined;

    constructor(data?: IMp4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.source = _data["source"] ? Source2.fromJS(_data["source"]) : <any>undefined;
            if (Array.isArray(_data["resolutions"])) {
                this.resolutions = [] as any;
                for (let item of _data["resolutions"])
                    this.resolutions!.push(Resolution1.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Mp4 {
        data = typeof data === 'object' ? data : {};
        let result = new Mp4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        if (Array.isArray(this.resolutions)) {
            data["resolutions"] = [];
            for (let item of this.resolutions)
                data["resolutions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMp4 {
    source?: Source2;
    resolutions?: Resolution1[] | undefined;
}

export class Variants implements IVariants {
    gif?: Gif;
    mp4?: Mp4;

    constructor(data?: IVariants) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gif = _data["gif"] ? Gif.fromJS(_data["gif"]) : <any>undefined;
            this.mp4 = _data["mp4"] ? Mp4.fromJS(_data["mp4"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Variants {
        data = typeof data === 'object' ? data : {};
        let result = new Variants();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gif"] = this.gif ? this.gif.toJSON() : <any>undefined;
        data["mp4"] = this.mp4 ? this.mp4.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IVariants {
    gif?: Gif;
    mp4?: Mp4;
}

export class Image implements IImage {
    source?: Source;
    resolutions?: Resolution2[] | undefined;
    variants?: Variants;
    id?: string | undefined;

    constructor(data?: IImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.source = _data["source"] ? Source.fromJS(_data["source"]) : <any>undefined;
            if (Array.isArray(_data["resolutions"])) {
                this.resolutions = [] as any;
                for (let item of _data["resolutions"])
                    this.resolutions!.push(Resolution2.fromJS(item));
            }
            this.variants = _data["variants"] ? Variants.fromJS(_data["variants"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Image {
        data = typeof data === 'object' ? data : {};
        let result = new Image();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        if (Array.isArray(this.resolutions)) {
            data["resolutions"] = [];
            for (let item of this.resolutions)
                data["resolutions"].push(item.toJSON());
        }
        data["variants"] = this.variants ? this.variants.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IImage {
    source?: Source;
    resolutions?: Resolution2[] | undefined;
    variants?: Variants;
    id?: string | undefined;
}

export class Preview implements IPreview {
    images?: Image[] | undefined;
    enabled?: boolean;

    constructor(data?: IPreview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(Image.fromJS(item));
            }
            this.enabled = _data["enabled"];
        }
    }

    static fromJS(data: any): Preview {
        data = typeof data === 'object' ? data : {};
        let result = new Preview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["enabled"] = this.enabled;
        return data; 
    }
}

export interface IPreview {
    images?: Image[] | undefined;
    enabled?: boolean;
}

export class Media_Embed1 implements IMedia_Embed1 {

    constructor(data?: IMedia_Embed1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Media_Embed1 {
        data = typeof data === 'object' ? data : {};
        let result = new Media_Embed1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IMedia_Embed1 {
}

export class Secure_Media_Embed1 implements ISecure_Media_Embed1 {

    constructor(data?: ISecure_Media_Embed1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Secure_Media_Embed1 {
        data = typeof data === 'object' ? data : {};
        let result = new Secure_Media_Embed1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface ISecure_Media_Embed1 {
}

export class Gildings1 implements IGildings1 {

    constructor(data?: IGildings1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Gildings1 {
        data = typeof data === 'object' ? data : {};
        let result = new Gildings1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGildings1 {
}

export class Source3 implements ISource3 {
    url?: string | undefined;
    width?: number;
    height?: number;

    constructor(data?: ISource3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): Source3 {
        data = typeof data === 'object' ? data : {};
        let result = new Source3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface ISource3 {
    url?: string | undefined;
    width?: number;
    height?: number;
}

export class Resolution3 implements IResolution3 {
    url?: string | undefined;
    width?: number;
    height?: number;

    constructor(data?: IResolution3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.width = _data["width"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any): Resolution3 {
        data = typeof data === 'object' ? data : {};
        let result = new Resolution3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface IResolution3 {
    url?: string | undefined;
    width?: number;
    height?: number;
}

export class Variants1 implements IVariants1 {

    constructor(data?: IVariants1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Variants1 {
        data = typeof data === 'object' ? data : {};
        let result = new Variants1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IVariants1 {
}

export class Image1 implements IImage1 {
    source?: Source3;
    resolutions?: Resolution3[] | undefined;
    variants?: Variants1;
    id?: string | undefined;

    constructor(data?: IImage1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.source = _data["source"] ? Source3.fromJS(_data["source"]) : <any>undefined;
            if (Array.isArray(_data["resolutions"])) {
                this.resolutions = [] as any;
                for (let item of _data["resolutions"])
                    this.resolutions!.push(Resolution3.fromJS(item));
            }
            this.variants = _data["variants"] ? Variants1.fromJS(_data["variants"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Image1 {
        data = typeof data === 'object' ? data : {};
        let result = new Image1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        if (Array.isArray(this.resolutions)) {
            data["resolutions"] = [];
            for (let item of this.resolutions)
                data["resolutions"].push(item.toJSON());
        }
        data["variants"] = this.variants ? this.variants.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IImage1 {
    source?: Source3;
    resolutions?: Resolution3[] | undefined;
    variants?: Variants1;
    id?: string | undefined;
}

export class Preview1 implements IPreview1 {
    images?: Image1[] | undefined;
    enabled?: boolean;

    constructor(data?: IPreview1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(Image1.fromJS(item));
            }
            this.enabled = _data["enabled"];
        }
    }

    static fromJS(data: any): Preview1 {
        data = typeof data === 'object' ? data : {};
        let result = new Preview1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["enabled"] = this.enabled;
        return data; 
    }
}

export interface IPreview1 {
    images?: Image1[] | undefined;
    enabled?: boolean;
}

export class Crosspost_Parent_List implements ICrosspost_Parent_List {
    approved_at_utc?: any | undefined;
    subreddit?: string | undefined;
    selftext?: string | undefined;
    author_fullname?: string | undefined;
    saved?: boolean;
    mod_reason_title?: any | undefined;
    gilded?: number;
    clicked?: boolean;
    title?: string | undefined;
    link_flair_richtext?: any[] | undefined;
    subreddit_name_prefixed?: string | undefined;
    hidden?: boolean;
    pwls?: number | undefined;
    link_flair_css_class?: any | undefined;
    downs?: number;
    thumbnail_height?: number;
    top_awarded_type?: any | undefined;
    hide_score?: boolean;
    name?: string | undefined;
    quarantine?: boolean;
    link_flair_text_color?: string | undefined;
    upvote_ratio?: number;
    author_flair_background_color?: any | undefined;
    subreddit_type?: string | undefined;
    ups?: number;
    total_awards_received?: number;
    media_embed?: Media_Embed1;
    thumbnail_width?: number;
    author_flair_template_id?: any | undefined;
    is_original_content?: boolean;
    user_reports?: any[] | undefined;
    secure_media?: any | undefined;
    is_reddit_media_domain?: boolean;
    is_meta?: boolean;
    category?: any | undefined;
    secure_media_embed?: Secure_Media_Embed1;
    link_flair_text?: any | undefined;
    can_mod_post?: boolean;
    score?: number;
    approved_by?: any | undefined;
    is_created_from_ads_ui?: boolean;
    author_premium?: boolean;
    thumbnail?: string | undefined;
    edited?: boolean;
    author_flair_css_class?: any | undefined;
    author_flair_richtext?: any[] | undefined;
    gildings?: Gildings1;
    post_hint?: string | undefined;
    content_categories?: any | undefined;
    is_self?: boolean;
    mod_note?: any | undefined;
    created?: number;
    link_flair_type?: string | undefined;
    wls?: number | undefined;
    removed_by_category?: any | undefined;
    banned_by?: any | undefined;
    author_flair_type?: string | undefined;
    domain?: string | undefined;
    allow_live_comments?: boolean;
    selftext_html?: any | undefined;
    likes?: any | undefined;
    suggested_sort?: any | undefined;
    banned_at_utc?: any | undefined;
    url_overridden_by_dest?: string | undefined;
    view_count?: any | undefined;
    archived?: boolean;
    no_follow?: boolean;
    is_crosspostable?: boolean;
    pinned?: boolean;
    over_18?: boolean;
    preview?: Preview1;
    all_awardings?: any[] | undefined;
    awarders?: any[] | undefined;
    media_only?: boolean;
    can_gild?: boolean;
    spoiler?: boolean;
    locked?: boolean;
    author_flair_text?: any | undefined;
    treatment_tags?: any[] | undefined;
    visited?: boolean;
    removed_by?: any | undefined;
    num_reports?: any | undefined;
    distinguished?: any | undefined;
    subreddit_id?: string | undefined;
    author_is_blocked?: boolean;
    mod_reason_by?: any | undefined;
    removal_reason?: any | undefined;
    link_flair_background_color?: string | undefined;
    id?: string | undefined;
    is_robot_indexable?: boolean;
    report_reasons?: any | undefined;
    author?: string | undefined;
    discussion_type?: any | undefined;
    num_comments?: number;
    send_replies?: boolean;
    whitelist_status?: string | undefined;
    contest_mode?: boolean;
    mod_reports?: any[] | undefined;
    author_patreon_flair?: boolean;
    author_flair_text_color?: any | undefined;
    permalink?: string | undefined;
    parent_whitelist_status?: string | undefined;
    stickied?: boolean;
    url?: string | undefined;
    subreddit_subscribers?: number;
    created_utc?: number;
    num_crossposts?: number;
    media?: any | undefined;
    is_video?: boolean;

    constructor(data?: ICrosspost_Parent_List) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approved_at_utc = _data["approved_at_utc"];
            this.subreddit = _data["subreddit"];
            this.selftext = _data["selftext"];
            this.author_fullname = _data["author_fullname"];
            this.saved = _data["saved"];
            this.mod_reason_title = _data["mod_reason_title"];
            this.gilded = _data["gilded"];
            this.clicked = _data["clicked"];
            this.title = _data["title"];
            if (Array.isArray(_data["link_flair_richtext"])) {
                this.link_flair_richtext = [] as any;
                for (let item of _data["link_flair_richtext"])
                    this.link_flair_richtext!.push(item);
            }
            this.subreddit_name_prefixed = _data["subreddit_name_prefixed"];
            this.hidden = _data["hidden"];
            this.pwls = _data["pwls"];
            this.link_flair_css_class = _data["link_flair_css_class"];
            this.downs = _data["downs"];
            this.thumbnail_height = _data["thumbnail_height"];
            this.top_awarded_type = _data["top_awarded_type"];
            this.hide_score = _data["hide_score"];
            this.name = _data["name"];
            this.quarantine = _data["quarantine"];
            this.link_flair_text_color = _data["link_flair_text_color"];
            this.upvote_ratio = _data["upvote_ratio"];
            this.author_flair_background_color = _data["author_flair_background_color"];
            this.subreddit_type = _data["subreddit_type"];
            this.ups = _data["ups"];
            this.total_awards_received = _data["total_awards_received"];
            this.media_embed = _data["media_embed"] ? Media_Embed1.fromJS(_data["media_embed"]) : <any>undefined;
            this.thumbnail_width = _data["thumbnail_width"];
            this.author_flair_template_id = _data["author_flair_template_id"];
            this.is_original_content = _data["is_original_content"];
            if (Array.isArray(_data["user_reports"])) {
                this.user_reports = [] as any;
                for (let item of _data["user_reports"])
                    this.user_reports!.push(item);
            }
            this.secure_media = _data["secure_media"];
            this.is_reddit_media_domain = _data["is_reddit_media_domain"];
            this.is_meta = _data["is_meta"];
            this.category = _data["category"];
            this.secure_media_embed = _data["secure_media_embed"] ? Secure_Media_Embed1.fromJS(_data["secure_media_embed"]) : <any>undefined;
            this.link_flair_text = _data["link_flair_text"];
            this.can_mod_post = _data["can_mod_post"];
            this.score = _data["score"];
            this.approved_by = _data["approved_by"];
            this.is_created_from_ads_ui = _data["is_created_from_ads_ui"];
            this.author_premium = _data["author_premium"];
            this.thumbnail = _data["thumbnail"];
            this.edited = _data["edited"];
            this.author_flair_css_class = _data["author_flair_css_class"];
            if (Array.isArray(_data["author_flair_richtext"])) {
                this.author_flair_richtext = [] as any;
                for (let item of _data["author_flair_richtext"])
                    this.author_flair_richtext!.push(item);
            }
            this.gildings = _data["gildings"] ? Gildings1.fromJS(_data["gildings"]) : <any>undefined;
            this.post_hint = _data["post_hint"];
            this.content_categories = _data["content_categories"];
            this.is_self = _data["is_self"];
            this.mod_note = _data["mod_note"];
            this.created = _data["created"];
            this.link_flair_type = _data["link_flair_type"];
            this.wls = _data["wls"];
            this.removed_by_category = _data["removed_by_category"];
            this.banned_by = _data["banned_by"];
            this.author_flair_type = _data["author_flair_type"];
            this.domain = _data["domain"];
            this.allow_live_comments = _data["allow_live_comments"];
            this.selftext_html = _data["selftext_html"];
            this.likes = _data["likes"];
            this.suggested_sort = _data["suggested_sort"];
            this.banned_at_utc = _data["banned_at_utc"];
            this.url_overridden_by_dest = _data["url_overridden_by_dest"];
            this.view_count = _data["view_count"];
            this.archived = _data["archived"];
            this.no_follow = _data["no_follow"];
            this.is_crosspostable = _data["is_crosspostable"];
            this.pinned = _data["pinned"];
            this.over_18 = _data["over_18"];
            this.preview = _data["preview"] ? Preview1.fromJS(_data["preview"]) : <any>undefined;
            if (Array.isArray(_data["all_awardings"])) {
                this.all_awardings = [] as any;
                for (let item of _data["all_awardings"])
                    this.all_awardings!.push(item);
            }
            if (Array.isArray(_data["awarders"])) {
                this.awarders = [] as any;
                for (let item of _data["awarders"])
                    this.awarders!.push(item);
            }
            this.media_only = _data["media_only"];
            this.can_gild = _data["can_gild"];
            this.spoiler = _data["spoiler"];
            this.locked = _data["locked"];
            this.author_flair_text = _data["author_flair_text"];
            if (Array.isArray(_data["treatment_tags"])) {
                this.treatment_tags = [] as any;
                for (let item of _data["treatment_tags"])
                    this.treatment_tags!.push(item);
            }
            this.visited = _data["visited"];
            this.removed_by = _data["removed_by"];
            this.num_reports = _data["num_reports"];
            this.distinguished = _data["distinguished"];
            this.subreddit_id = _data["subreddit_id"];
            this.author_is_blocked = _data["author_is_blocked"];
            this.mod_reason_by = _data["mod_reason_by"];
            this.removal_reason = _data["removal_reason"];
            this.link_flair_background_color = _data["link_flair_background_color"];
            this.id = _data["id"];
            this.is_robot_indexable = _data["is_robot_indexable"];
            this.report_reasons = _data["report_reasons"];
            this.author = _data["author"];
            this.discussion_type = _data["discussion_type"];
            this.num_comments = _data["num_comments"];
            this.send_replies = _data["send_replies"];
            this.whitelist_status = _data["whitelist_status"];
            this.contest_mode = _data["contest_mode"];
            if (Array.isArray(_data["mod_reports"])) {
                this.mod_reports = [] as any;
                for (let item of _data["mod_reports"])
                    this.mod_reports!.push(item);
            }
            this.author_patreon_flair = _data["author_patreon_flair"];
            this.author_flair_text_color = _data["author_flair_text_color"];
            this.permalink = _data["permalink"];
            this.parent_whitelist_status = _data["parent_whitelist_status"];
            this.stickied = _data["stickied"];
            this.url = _data["url"];
            this.subreddit_subscribers = _data["subreddit_subscribers"];
            this.created_utc = _data["created_utc"];
            this.num_crossposts = _data["num_crossposts"];
            this.media = _data["media"];
            this.is_video = _data["is_video"];
        }
    }

    static fromJS(data: any): Crosspost_Parent_List {
        data = typeof data === 'object' ? data : {};
        let result = new Crosspost_Parent_List();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approved_at_utc"] = this.approved_at_utc;
        data["subreddit"] = this.subreddit;
        data["selftext"] = this.selftext;
        data["author_fullname"] = this.author_fullname;
        data["saved"] = this.saved;
        data["mod_reason_title"] = this.mod_reason_title;
        data["gilded"] = this.gilded;
        data["clicked"] = this.clicked;
        data["title"] = this.title;
        if (Array.isArray(this.link_flair_richtext)) {
            data["link_flair_richtext"] = [];
            for (let item of this.link_flair_richtext)
                data["link_flair_richtext"].push(item);
        }
        data["subreddit_name_prefixed"] = this.subreddit_name_prefixed;
        data["hidden"] = this.hidden;
        data["pwls"] = this.pwls;
        data["link_flair_css_class"] = this.link_flair_css_class;
        data["downs"] = this.downs;
        data["thumbnail_height"] = this.thumbnail_height;
        data["top_awarded_type"] = this.top_awarded_type;
        data["hide_score"] = this.hide_score;
        data["name"] = this.name;
        data["quarantine"] = this.quarantine;
        data["link_flair_text_color"] = this.link_flair_text_color;
        data["upvote_ratio"] = this.upvote_ratio;
        data["author_flair_background_color"] = this.author_flair_background_color;
        data["subreddit_type"] = this.subreddit_type;
        data["ups"] = this.ups;
        data["total_awards_received"] = this.total_awards_received;
        data["media_embed"] = this.media_embed ? this.media_embed.toJSON() : <any>undefined;
        data["thumbnail_width"] = this.thumbnail_width;
        data["author_flair_template_id"] = this.author_flair_template_id;
        data["is_original_content"] = this.is_original_content;
        if (Array.isArray(this.user_reports)) {
            data["user_reports"] = [];
            for (let item of this.user_reports)
                data["user_reports"].push(item);
        }
        data["secure_media"] = this.secure_media;
        data["is_reddit_media_domain"] = this.is_reddit_media_domain;
        data["is_meta"] = this.is_meta;
        data["category"] = this.category;
        data["secure_media_embed"] = this.secure_media_embed ? this.secure_media_embed.toJSON() : <any>undefined;
        data["link_flair_text"] = this.link_flair_text;
        data["can_mod_post"] = this.can_mod_post;
        data["score"] = this.score;
        data["approved_by"] = this.approved_by;
        data["is_created_from_ads_ui"] = this.is_created_from_ads_ui;
        data["author_premium"] = this.author_premium;
        data["thumbnail"] = this.thumbnail;
        data["edited"] = this.edited;
        data["author_flair_css_class"] = this.author_flair_css_class;
        if (Array.isArray(this.author_flair_richtext)) {
            data["author_flair_richtext"] = [];
            for (let item of this.author_flair_richtext)
                data["author_flair_richtext"].push(item);
        }
        data["gildings"] = this.gildings ? this.gildings.toJSON() : <any>undefined;
        data["post_hint"] = this.post_hint;
        data["content_categories"] = this.content_categories;
        data["is_self"] = this.is_self;
        data["mod_note"] = this.mod_note;
        data["created"] = this.created;
        data["link_flair_type"] = this.link_flair_type;
        data["wls"] = this.wls;
        data["removed_by_category"] = this.removed_by_category;
        data["banned_by"] = this.banned_by;
        data["author_flair_type"] = this.author_flair_type;
        data["domain"] = this.domain;
        data["allow_live_comments"] = this.allow_live_comments;
        data["selftext_html"] = this.selftext_html;
        data["likes"] = this.likes;
        data["suggested_sort"] = this.suggested_sort;
        data["banned_at_utc"] = this.banned_at_utc;
        data["url_overridden_by_dest"] = this.url_overridden_by_dest;
        data["view_count"] = this.view_count;
        data["archived"] = this.archived;
        data["no_follow"] = this.no_follow;
        data["is_crosspostable"] = this.is_crosspostable;
        data["pinned"] = this.pinned;
        data["over_18"] = this.over_18;
        data["preview"] = this.preview ? this.preview.toJSON() : <any>undefined;
        if (Array.isArray(this.all_awardings)) {
            data["all_awardings"] = [];
            for (let item of this.all_awardings)
                data["all_awardings"].push(item);
        }
        if (Array.isArray(this.awarders)) {
            data["awarders"] = [];
            for (let item of this.awarders)
                data["awarders"].push(item);
        }
        data["media_only"] = this.media_only;
        data["can_gild"] = this.can_gild;
        data["spoiler"] = this.spoiler;
        data["locked"] = this.locked;
        data["author_flair_text"] = this.author_flair_text;
        if (Array.isArray(this.treatment_tags)) {
            data["treatment_tags"] = [];
            for (let item of this.treatment_tags)
                data["treatment_tags"].push(item);
        }
        data["visited"] = this.visited;
        data["removed_by"] = this.removed_by;
        data["num_reports"] = this.num_reports;
        data["distinguished"] = this.distinguished;
        data["subreddit_id"] = this.subreddit_id;
        data["author_is_blocked"] = this.author_is_blocked;
        data["mod_reason_by"] = this.mod_reason_by;
        data["removal_reason"] = this.removal_reason;
        data["link_flair_background_color"] = this.link_flair_background_color;
        data["id"] = this.id;
        data["is_robot_indexable"] = this.is_robot_indexable;
        data["report_reasons"] = this.report_reasons;
        data["author"] = this.author;
        data["discussion_type"] = this.discussion_type;
        data["num_comments"] = this.num_comments;
        data["send_replies"] = this.send_replies;
        data["whitelist_status"] = this.whitelist_status;
        data["contest_mode"] = this.contest_mode;
        if (Array.isArray(this.mod_reports)) {
            data["mod_reports"] = [];
            for (let item of this.mod_reports)
                data["mod_reports"].push(item);
        }
        data["author_patreon_flair"] = this.author_patreon_flair;
        data["author_flair_text_color"] = this.author_flair_text_color;
        data["permalink"] = this.permalink;
        data["parent_whitelist_status"] = this.parent_whitelist_status;
        data["stickied"] = this.stickied;
        data["url"] = this.url;
        data["subreddit_subscribers"] = this.subreddit_subscribers;
        data["created_utc"] = this.created_utc;
        data["num_crossposts"] = this.num_crossposts;
        data["media"] = this.media;
        data["is_video"] = this.is_video;
        return data; 
    }
}

export interface ICrosspost_Parent_List {
    approved_at_utc?: any | undefined;
    subreddit?: string | undefined;
    selftext?: string | undefined;
    author_fullname?: string | undefined;
    saved?: boolean;
    mod_reason_title?: any | undefined;
    gilded?: number;
    clicked?: boolean;
    title?: string | undefined;
    link_flair_richtext?: any[] | undefined;
    subreddit_name_prefixed?: string | undefined;
    hidden?: boolean;
    pwls?: number | undefined;
    link_flair_css_class?: any | undefined;
    downs?: number;
    thumbnail_height?: number;
    top_awarded_type?: any | undefined;
    hide_score?: boolean;
    name?: string | undefined;
    quarantine?: boolean;
    link_flair_text_color?: string | undefined;
    upvote_ratio?: number;
    author_flair_background_color?: any | undefined;
    subreddit_type?: string | undefined;
    ups?: number;
    total_awards_received?: number;
    media_embed?: Media_Embed1;
    thumbnail_width?: number;
    author_flair_template_id?: any | undefined;
    is_original_content?: boolean;
    user_reports?: any[] | undefined;
    secure_media?: any | undefined;
    is_reddit_media_domain?: boolean;
    is_meta?: boolean;
    category?: any | undefined;
    secure_media_embed?: Secure_Media_Embed1;
    link_flair_text?: any | undefined;
    can_mod_post?: boolean;
    score?: number;
    approved_by?: any | undefined;
    is_created_from_ads_ui?: boolean;
    author_premium?: boolean;
    thumbnail?: string | undefined;
    edited?: boolean;
    author_flair_css_class?: any | undefined;
    author_flair_richtext?: any[] | undefined;
    gildings?: Gildings1;
    post_hint?: string | undefined;
    content_categories?: any | undefined;
    is_self?: boolean;
    mod_note?: any | undefined;
    created?: number;
    link_flair_type?: string | undefined;
    wls?: number | undefined;
    removed_by_category?: any | undefined;
    banned_by?: any | undefined;
    author_flair_type?: string | undefined;
    domain?: string | undefined;
    allow_live_comments?: boolean;
    selftext_html?: any | undefined;
    likes?: any | undefined;
    suggested_sort?: any | undefined;
    banned_at_utc?: any | undefined;
    url_overridden_by_dest?: string | undefined;
    view_count?: any | undefined;
    archived?: boolean;
    no_follow?: boolean;
    is_crosspostable?: boolean;
    pinned?: boolean;
    over_18?: boolean;
    preview?: Preview1;
    all_awardings?: any[] | undefined;
    awarders?: any[] | undefined;
    media_only?: boolean;
    can_gild?: boolean;
    spoiler?: boolean;
    locked?: boolean;
    author_flair_text?: any | undefined;
    treatment_tags?: any[] | undefined;
    visited?: boolean;
    removed_by?: any | undefined;
    num_reports?: any | undefined;
    distinguished?: any | undefined;
    subreddit_id?: string | undefined;
    author_is_blocked?: boolean;
    mod_reason_by?: any | undefined;
    removal_reason?: any | undefined;
    link_flair_background_color?: string | undefined;
    id?: string | undefined;
    is_robot_indexable?: boolean;
    report_reasons?: any | undefined;
    author?: string | undefined;
    discussion_type?: any | undefined;
    num_comments?: number;
    send_replies?: boolean;
    whitelist_status?: string | undefined;
    contest_mode?: boolean;
    mod_reports?: any[] | undefined;
    author_patreon_flair?: boolean;
    author_flair_text_color?: any | undefined;
    permalink?: string | undefined;
    parent_whitelist_status?: string | undefined;
    stickied?: boolean;
    url?: string | undefined;
    subreddit_subscribers?: number;
    created_utc?: number;
    num_crossposts?: number;
    media?: any | undefined;
    is_video?: boolean;
}

export class FavouritData implements IFavouritData {
    approved_at_utc?: any | undefined;
    subreddit?: string | undefined;
    selftext?: string | undefined;
    author_fullname?: string | undefined;
    saved?: boolean;
    mod_reason_title?: any | undefined;
    gilded?: number;
    clicked?: boolean;
    title?: string | undefined;
    link_flair_richtext?: Link_Flair_Richtext[] | undefined;
    subreddit_name_prefixed?: string | undefined;
    hidden?: boolean;
    pwls?: number;
    link_flair_css_class?: string | undefined;
    downs?: number;
    thumbnail_height?: number | undefined;
    top_awarded_type?: any | undefined;
    hide_score?: boolean;
    name?: string | undefined;
    quarantine?: boolean;
    link_flair_text_color?: string | undefined;
    upvote_ratio?: number;
    author_flair_background_color?: string | undefined;
    subreddit_type?: string | undefined;
    ups?: number;
    total_awards_received?: number;
    media_embed?: Media_Embed;
    thumbnail_width?: number | undefined;
    author_flair_template_id?: string | undefined;
    is_original_content?: boolean;
    user_reports?: any[] | undefined;
    secure_media?: Secure_Media;
    is_reddit_media_domain?: boolean;
    is_meta?: boolean;
    category?: any | undefined;
    secure_media_embed?: Secure_Media_Embed;
    link_flair_text?: string | undefined;
    can_mod_post?: boolean;
    score?: number;
    approved_by?: any | undefined;
    is_created_from_ads_ui?: boolean;
    author_premium?: boolean;
    thumbnail?: string | undefined;
    edited?: any | undefined;
    author_flair_css_class?: string | undefined;
    author_flair_richtext?: Author_Flair_Richtext[] | undefined;
    gildings?: Gildings;
    content_categories?: any | undefined;
    is_self?: boolean;
    mod_note?: any | undefined;
    created?: number;
    link_flair_type?: string | undefined;
    wls?: number;
    removed_by_category?: any | undefined;
    banned_by?: any | undefined;
    author_flair_type?: string | undefined;
    domain?: string | undefined;
    allow_live_comments?: boolean;
    selftext_html?: string | undefined;
    likes?: any | undefined;
    suggested_sort?: string | undefined;
    banned_at_utc?: any | undefined;
    view_count?: any | undefined;
    archived?: boolean;
    no_follow?: boolean;
    is_crosspostable?: boolean;
    pinned?: boolean;
    over_18?: boolean;
    all_awardings?: All_Awardings[] | undefined;
    awarders?: any[] | undefined;
    media_only?: boolean;
    link_flair_template_id?: string | undefined;
    can_gild?: boolean;
    spoiler?: boolean;
    locked?: boolean;
    author_flair_text?: string | undefined;
    treatment_tags?: any[] | undefined;
    visited?: boolean;
    removed_by?: any | undefined;
    num_reports?: any | undefined;
    distinguished?: any | undefined;
    subreddit_id?: string | undefined;
    author_is_blocked?: boolean;
    mod_reason_by?: any | undefined;
    removal_reason?: any | undefined;
    link_flair_background_color?: string | undefined;
    id?: string | undefined;
    is_robot_indexable?: boolean;
    report_reasons?: any | undefined;
    author?: string | undefined;
    discussion_type?: any | undefined;
    num_comments?: number;
    send_replies?: boolean;
    whitelist_status?: string | undefined;
    contest_mode?: boolean;
    mod_reports?: any[] | undefined;
    author_patreon_flair?: boolean;
    author_flair_text_color?: string | undefined;
    permalink?: string | undefined;
    parent_whitelist_status?: string | undefined;
    stickied?: boolean;
    url?: string | undefined;
    subreddit_subscribers?: number;
    created_utc?: number;
    num_crossposts?: number;
    media?: Media;
    is_video?: boolean;
    post_hint?: string | undefined;
    url_overridden_by_dest?: string | undefined;
    preview?: Preview;
    crosspost_parent_list?: Crosspost_Parent_List[] | undefined;
    crosspost_parent?: string | undefined;

    constructor(data?: IFavouritData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approved_at_utc = _data["approved_at_utc"];
            this.subreddit = _data["subreddit"];
            this.selftext = _data["selftext"];
            this.author_fullname = _data["author_fullname"];
            this.saved = _data["saved"];
            this.mod_reason_title = _data["mod_reason_title"];
            this.gilded = _data["gilded"];
            this.clicked = _data["clicked"];
            this.title = _data["title"];
            if (Array.isArray(_data["link_flair_richtext"])) {
                this.link_flair_richtext = [] as any;
                for (let item of _data["link_flair_richtext"])
                    this.link_flair_richtext!.push(Link_Flair_Richtext.fromJS(item));
            }
            this.subreddit_name_prefixed = _data["subreddit_name_prefixed"];
            this.hidden = _data["hidden"];
            this.pwls = _data["pwls"];
            this.link_flair_css_class = _data["link_flair_css_class"];
            this.downs = _data["downs"];
            this.thumbnail_height = _data["thumbnail_height"];
            this.top_awarded_type = _data["top_awarded_type"];
            this.hide_score = _data["hide_score"];
            this.name = _data["name"];
            this.quarantine = _data["quarantine"];
            this.link_flair_text_color = _data["link_flair_text_color"];
            this.upvote_ratio = _data["upvote_ratio"];
            this.author_flair_background_color = _data["author_flair_background_color"];
            this.subreddit_type = _data["subreddit_type"];
            this.ups = _data["ups"];
            this.total_awards_received = _data["total_awards_received"];
            this.media_embed = _data["media_embed"] ? Media_Embed.fromJS(_data["media_embed"]) : <any>undefined;
            this.thumbnail_width = _data["thumbnail_width"];
            this.author_flair_template_id = _data["author_flair_template_id"];
            this.is_original_content = _data["is_original_content"];
            if (Array.isArray(_data["user_reports"])) {
                this.user_reports = [] as any;
                for (let item of _data["user_reports"])
                    this.user_reports!.push(item);
            }
            this.secure_media = _data["secure_media"] ? Secure_Media.fromJS(_data["secure_media"]) : <any>undefined;
            this.is_reddit_media_domain = _data["is_reddit_media_domain"];
            this.is_meta = _data["is_meta"];
            this.category = _data["category"];
            this.secure_media_embed = _data["secure_media_embed"] ? Secure_Media_Embed.fromJS(_data["secure_media_embed"]) : <any>undefined;
            this.link_flair_text = _data["link_flair_text"];
            this.can_mod_post = _data["can_mod_post"];
            this.score = _data["score"];
            this.approved_by = _data["approved_by"];
            this.is_created_from_ads_ui = _data["is_created_from_ads_ui"];
            this.author_premium = _data["author_premium"];
            this.thumbnail = _data["thumbnail"];
            this.edited = _data["edited"];
            this.author_flair_css_class = _data["author_flair_css_class"];
            if (Array.isArray(_data["author_flair_richtext"])) {
                this.author_flair_richtext = [] as any;
                for (let item of _data["author_flair_richtext"])
                    this.author_flair_richtext!.push(Author_Flair_Richtext.fromJS(item));
            }
            this.gildings = _data["gildings"] ? Gildings.fromJS(_data["gildings"]) : <any>undefined;
            this.content_categories = _data["content_categories"];
            this.is_self = _data["is_self"];
            this.mod_note = _data["mod_note"];
            this.created = _data["created"];
            this.link_flair_type = _data["link_flair_type"];
            this.wls = _data["wls"];
            this.removed_by_category = _data["removed_by_category"];
            this.banned_by = _data["banned_by"];
            this.author_flair_type = _data["author_flair_type"];
            this.domain = _data["domain"];
            this.allow_live_comments = _data["allow_live_comments"];
            this.selftext_html = _data["selftext_html"];
            this.likes = _data["likes"];
            this.suggested_sort = _data["suggested_sort"];
            this.banned_at_utc = _data["banned_at_utc"];
            this.view_count = _data["view_count"];
            this.archived = _data["archived"];
            this.no_follow = _data["no_follow"];
            this.is_crosspostable = _data["is_crosspostable"];
            this.pinned = _data["pinned"];
            this.over_18 = _data["over_18"];
            if (Array.isArray(_data["all_awardings"])) {
                this.all_awardings = [] as any;
                for (let item of _data["all_awardings"])
                    this.all_awardings!.push(All_Awardings.fromJS(item));
            }
            if (Array.isArray(_data["awarders"])) {
                this.awarders = [] as any;
                for (let item of _data["awarders"])
                    this.awarders!.push(item);
            }
            this.media_only = _data["media_only"];
            this.link_flair_template_id = _data["link_flair_template_id"];
            this.can_gild = _data["can_gild"];
            this.spoiler = _data["spoiler"];
            this.locked = _data["locked"];
            this.author_flair_text = _data["author_flair_text"];
            if (Array.isArray(_data["treatment_tags"])) {
                this.treatment_tags = [] as any;
                for (let item of _data["treatment_tags"])
                    this.treatment_tags!.push(item);
            }
            this.visited = _data["visited"];
            this.removed_by = _data["removed_by"];
            this.num_reports = _data["num_reports"];
            this.distinguished = _data["distinguished"];
            this.subreddit_id = _data["subreddit_id"];
            this.author_is_blocked = _data["author_is_blocked"];
            this.mod_reason_by = _data["mod_reason_by"];
            this.removal_reason = _data["removal_reason"];
            this.link_flair_background_color = _data["link_flair_background_color"];
            this.id = _data["id"];
            this.is_robot_indexable = _data["is_robot_indexable"];
            this.report_reasons = _data["report_reasons"];
            this.author = _data["author"];
            this.discussion_type = _data["discussion_type"];
            this.num_comments = _data["num_comments"];
            this.send_replies = _data["send_replies"];
            this.whitelist_status = _data["whitelist_status"];
            this.contest_mode = _data["contest_mode"];
            if (Array.isArray(_data["mod_reports"])) {
                this.mod_reports = [] as any;
                for (let item of _data["mod_reports"])
                    this.mod_reports!.push(item);
            }
            this.author_patreon_flair = _data["author_patreon_flair"];
            this.author_flair_text_color = _data["author_flair_text_color"];
            this.permalink = _data["permalink"];
            this.parent_whitelist_status = _data["parent_whitelist_status"];
            this.stickied = _data["stickied"];
            this.url = _data["url"];
            this.subreddit_subscribers = _data["subreddit_subscribers"];
            this.created_utc = _data["created_utc"];
            this.num_crossposts = _data["num_crossposts"];
            this.media = _data["media"] ? Media.fromJS(_data["media"]) : <any>undefined;
            this.is_video = _data["is_video"];
            this.post_hint = _data["post_hint"];
            this.url_overridden_by_dest = _data["url_overridden_by_dest"];
            this.preview = _data["preview"] ? Preview.fromJS(_data["preview"]) : <any>undefined;
            if (Array.isArray(_data["crosspost_parent_list"])) {
                this.crosspost_parent_list = [] as any;
                for (let item of _data["crosspost_parent_list"])
                    this.crosspost_parent_list!.push(Crosspost_Parent_List.fromJS(item));
            }
            this.crosspost_parent = _data["crosspost_parent"];
        }
    }

    static fromJS(data: any): FavouritData {
        data = typeof data === 'object' ? data : {};
        let result = new FavouritData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approved_at_utc"] = this.approved_at_utc;
        data["subreddit"] = this.subreddit;
        data["selftext"] = this.selftext;
        data["author_fullname"] = this.author_fullname;
        data["saved"] = this.saved;
        data["mod_reason_title"] = this.mod_reason_title;
        data["gilded"] = this.gilded;
        data["clicked"] = this.clicked;
        data["title"] = this.title;
        if (Array.isArray(this.link_flair_richtext)) {
            data["link_flair_richtext"] = [];
            for (let item of this.link_flair_richtext)
                data["link_flair_richtext"].push(item.toJSON());
        }
        data["subreddit_name_prefixed"] = this.subreddit_name_prefixed;
        data["hidden"] = this.hidden;
        data["pwls"] = this.pwls;
        data["link_flair_css_class"] = this.link_flair_css_class;
        data["downs"] = this.downs;
        data["thumbnail_height"] = this.thumbnail_height;
        data["top_awarded_type"] = this.top_awarded_type;
        data["hide_score"] = this.hide_score;
        data["name"] = this.name;
        data["quarantine"] = this.quarantine;
        data["link_flair_text_color"] = this.link_flair_text_color;
        data["upvote_ratio"] = this.upvote_ratio;
        data["author_flair_background_color"] = this.author_flair_background_color;
        data["subreddit_type"] = this.subreddit_type;
        data["ups"] = this.ups;
        data["total_awards_received"] = this.total_awards_received;
        data["media_embed"] = this.media_embed ? this.media_embed.toJSON() : <any>undefined;
        data["thumbnail_width"] = this.thumbnail_width;
        data["author_flair_template_id"] = this.author_flair_template_id;
        data["is_original_content"] = this.is_original_content;
        if (Array.isArray(this.user_reports)) {
            data["user_reports"] = [];
            for (let item of this.user_reports)
                data["user_reports"].push(item);
        }
        data["secure_media"] = this.secure_media ? this.secure_media.toJSON() : <any>undefined;
        data["is_reddit_media_domain"] = this.is_reddit_media_domain;
        data["is_meta"] = this.is_meta;
        data["category"] = this.category;
        data["secure_media_embed"] = this.secure_media_embed ? this.secure_media_embed.toJSON() : <any>undefined;
        data["link_flair_text"] = this.link_flair_text;
        data["can_mod_post"] = this.can_mod_post;
        data["score"] = this.score;
        data["approved_by"] = this.approved_by;
        data["is_created_from_ads_ui"] = this.is_created_from_ads_ui;
        data["author_premium"] = this.author_premium;
        data["thumbnail"] = this.thumbnail;
        data["edited"] = this.edited;
        data["author_flair_css_class"] = this.author_flair_css_class;
        if (Array.isArray(this.author_flair_richtext)) {
            data["author_flair_richtext"] = [];
            for (let item of this.author_flair_richtext)
                data["author_flair_richtext"].push(item.toJSON());
        }
        data["gildings"] = this.gildings ? this.gildings.toJSON() : <any>undefined;
        data["content_categories"] = this.content_categories;
        data["is_self"] = this.is_self;
        data["mod_note"] = this.mod_note;
        data["created"] = this.created;
        data["link_flair_type"] = this.link_flair_type;
        data["wls"] = this.wls;
        data["removed_by_category"] = this.removed_by_category;
        data["banned_by"] = this.banned_by;
        data["author_flair_type"] = this.author_flair_type;
        data["domain"] = this.domain;
        data["allow_live_comments"] = this.allow_live_comments;
        data["selftext_html"] = this.selftext_html;
        data["likes"] = this.likes;
        data["suggested_sort"] = this.suggested_sort;
        data["banned_at_utc"] = this.banned_at_utc;
        data["view_count"] = this.view_count;
        data["archived"] = this.archived;
        data["no_follow"] = this.no_follow;
        data["is_crosspostable"] = this.is_crosspostable;
        data["pinned"] = this.pinned;
        data["over_18"] = this.over_18;
        if (Array.isArray(this.all_awardings)) {
            data["all_awardings"] = [];
            for (let item of this.all_awardings)
                data["all_awardings"].push(item.toJSON());
        }
        if (Array.isArray(this.awarders)) {
            data["awarders"] = [];
            for (let item of this.awarders)
                data["awarders"].push(item);
        }
        data["media_only"] = this.media_only;
        data["link_flair_template_id"] = this.link_flair_template_id;
        data["can_gild"] = this.can_gild;
        data["spoiler"] = this.spoiler;
        data["locked"] = this.locked;
        data["author_flair_text"] = this.author_flair_text;
        if (Array.isArray(this.treatment_tags)) {
            data["treatment_tags"] = [];
            for (let item of this.treatment_tags)
                data["treatment_tags"].push(item);
        }
        data["visited"] = this.visited;
        data["removed_by"] = this.removed_by;
        data["num_reports"] = this.num_reports;
        data["distinguished"] = this.distinguished;
        data["subreddit_id"] = this.subreddit_id;
        data["author_is_blocked"] = this.author_is_blocked;
        data["mod_reason_by"] = this.mod_reason_by;
        data["removal_reason"] = this.removal_reason;
        data["link_flair_background_color"] = this.link_flair_background_color;
        data["id"] = this.id;
        data["is_robot_indexable"] = this.is_robot_indexable;
        data["report_reasons"] = this.report_reasons;
        data["author"] = this.author;
        data["discussion_type"] = this.discussion_type;
        data["num_comments"] = this.num_comments;
        data["send_replies"] = this.send_replies;
        data["whitelist_status"] = this.whitelist_status;
        data["contest_mode"] = this.contest_mode;
        if (Array.isArray(this.mod_reports)) {
            data["mod_reports"] = [];
            for (let item of this.mod_reports)
                data["mod_reports"].push(item);
        }
        data["author_patreon_flair"] = this.author_patreon_flair;
        data["author_flair_text_color"] = this.author_flair_text_color;
        data["permalink"] = this.permalink;
        data["parent_whitelist_status"] = this.parent_whitelist_status;
        data["stickied"] = this.stickied;
        data["url"] = this.url;
        data["subreddit_subscribers"] = this.subreddit_subscribers;
        data["created_utc"] = this.created_utc;
        data["num_crossposts"] = this.num_crossposts;
        data["media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["is_video"] = this.is_video;
        data["post_hint"] = this.post_hint;
        data["url_overridden_by_dest"] = this.url_overridden_by_dest;
        data["preview"] = this.preview ? this.preview.toJSON() : <any>undefined;
        if (Array.isArray(this.crosspost_parent_list)) {
            data["crosspost_parent_list"] = [];
            for (let item of this.crosspost_parent_list)
                data["crosspost_parent_list"].push(item.toJSON());
        }
        data["crosspost_parent"] = this.crosspost_parent;
        return data; 
    }
}

export interface IFavouritData {
    approved_at_utc?: any | undefined;
    subreddit?: string | undefined;
    selftext?: string | undefined;
    author_fullname?: string | undefined;
    saved?: boolean;
    mod_reason_title?: any | undefined;
    gilded?: number;
    clicked?: boolean;
    title?: string | undefined;
    link_flair_richtext?: Link_Flair_Richtext[] | undefined;
    subreddit_name_prefixed?: string | undefined;
    hidden?: boolean;
    pwls?: number;
    link_flair_css_class?: string | undefined;
    downs?: number;
    thumbnail_height?: number | undefined;
    top_awarded_type?: any | undefined;
    hide_score?: boolean;
    name?: string | undefined;
    quarantine?: boolean;
    link_flair_text_color?: string | undefined;
    upvote_ratio?: number;
    author_flair_background_color?: string | undefined;
    subreddit_type?: string | undefined;
    ups?: number;
    total_awards_received?: number;
    media_embed?: Media_Embed;
    thumbnail_width?: number | undefined;
    author_flair_template_id?: string | undefined;
    is_original_content?: boolean;
    user_reports?: any[] | undefined;
    secure_media?: Secure_Media;
    is_reddit_media_domain?: boolean;
    is_meta?: boolean;
    category?: any | undefined;
    secure_media_embed?: Secure_Media_Embed;
    link_flair_text?: string | undefined;
    can_mod_post?: boolean;
    score?: number;
    approved_by?: any | undefined;
    is_created_from_ads_ui?: boolean;
    author_premium?: boolean;
    thumbnail?: string | undefined;
    edited?: any | undefined;
    author_flair_css_class?: string | undefined;
    author_flair_richtext?: Author_Flair_Richtext[] | undefined;
    gildings?: Gildings;
    content_categories?: any | undefined;
    is_self?: boolean;
    mod_note?: any | undefined;
    created?: number;
    link_flair_type?: string | undefined;
    wls?: number;
    removed_by_category?: any | undefined;
    banned_by?: any | undefined;
    author_flair_type?: string | undefined;
    domain?: string | undefined;
    allow_live_comments?: boolean;
    selftext_html?: string | undefined;
    likes?: any | undefined;
    suggested_sort?: string | undefined;
    banned_at_utc?: any | undefined;
    view_count?: any | undefined;
    archived?: boolean;
    no_follow?: boolean;
    is_crosspostable?: boolean;
    pinned?: boolean;
    over_18?: boolean;
    all_awardings?: All_Awardings[] | undefined;
    awarders?: any[] | undefined;
    media_only?: boolean;
    link_flair_template_id?: string | undefined;
    can_gild?: boolean;
    spoiler?: boolean;
    locked?: boolean;
    author_flair_text?: string | undefined;
    treatment_tags?: any[] | undefined;
    visited?: boolean;
    removed_by?: any | undefined;
    num_reports?: any | undefined;
    distinguished?: any | undefined;
    subreddit_id?: string | undefined;
    author_is_blocked?: boolean;
    mod_reason_by?: any | undefined;
    removal_reason?: any | undefined;
    link_flair_background_color?: string | undefined;
    id?: string | undefined;
    is_robot_indexable?: boolean;
    report_reasons?: any | undefined;
    author?: string | undefined;
    discussion_type?: any | undefined;
    num_comments?: number;
    send_replies?: boolean;
    whitelist_status?: string | undefined;
    contest_mode?: boolean;
    mod_reports?: any[] | undefined;
    author_patreon_flair?: boolean;
    author_flair_text_color?: string | undefined;
    permalink?: string | undefined;
    parent_whitelist_status?: string | undefined;
    stickied?: boolean;
    url?: string | undefined;
    subreddit_subscribers?: number;
    created_utc?: number;
    num_crossposts?: number;
    media?: Media;
    is_video?: boolean;
    post_hint?: string | undefined;
    url_overridden_by_dest?: string | undefined;
    preview?: Preview;
    crosspost_parent_list?: Crosspost_Parent_List[] | undefined;
    crosspost_parent?: string | undefined;
}

export class FavouritRoot implements IFavouritRoot {
    kind?: string | undefined;
    data?: FavouritData;

    constructor(data?: IFavouritRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kind = _data["kind"];
            this.data = _data["data"] ? FavouritData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FavouritRoot {
        data = typeof data === 'object' ? data : {};
        let result = new FavouritRoot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFavouritRoot {
    kind?: string | undefined;
    data?: FavouritData;
}

export class RedditFavouritsResponceData implements IRedditFavouritsResponceData {
    after?: string | undefined;
    dist?: number;
    modhash?: any | undefined;
    geo_filter?: string | undefined;
    children?: FavouritRoot[] | undefined;
    before?: any | undefined;

    constructor(data?: IRedditFavouritsResponceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.after = _data["after"];
            this.dist = _data["dist"];
            this.modhash = _data["modhash"];
            this.geo_filter = _data["geo_filter"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(FavouritRoot.fromJS(item));
            }
            this.before = _data["before"];
        }
    }

    static fromJS(data: any): RedditFavouritsResponceData {
        data = typeof data === 'object' ? data : {};
        let result = new RedditFavouritsResponceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["after"] = this.after;
        data["dist"] = this.dist;
        data["modhash"] = this.modhash;
        data["geo_filter"] = this.geo_filter;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["before"] = this.before;
        return data; 
    }
}

export interface IRedditFavouritsResponceData {
    after?: string | undefined;
    dist?: number;
    modhash?: any | undefined;
    geo_filter?: string | undefined;
    children?: FavouritRoot[] | undefined;
    before?: any | undefined;
}

export class RedditFavouritsResponceRoot implements IRedditFavouritsResponceRoot {
    kind?: string | undefined;
    data?: RedditFavouritsResponceData;

    constructor(data?: IRedditFavouritsResponceRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kind = _data["kind"];
            this.data = _data["data"] ? RedditFavouritsResponceData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RedditFavouritsResponceRoot {
        data = typeof data === 'object' ? data : {};
        let result = new RedditFavouritsResponceRoot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRedditFavouritsResponceRoot {
    kind?: string | undefined;
    data?: RedditFavouritsResponceData;
}

export class UserTokenData implements IUserTokenData {
    token!: string;

    constructor(data?: IUserTokenData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): UserTokenData {
        data = typeof data === 'object' ? data : {};
        let result = new UserTokenData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data; 
    }
}

export interface IUserTokenData {
    token: string;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    readonly temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            (<any>this).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data; 
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}